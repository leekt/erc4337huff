// TODO getNonce(address _sender, uint192 _key);
// TODO getUserOpHash(UserOperation calldata _op);
// TODO function handleOps(UserOperation[] calldata ops, address payable beneficiary);
#include "./UserOperation.huff"

// UserOp
//struct UserOperation {
//    address sender; UOO
//    uint256 nonce; UOO+0x20
//    bytes initCode; UOO+0x40
//    bytes callData; UOO+0x60
//    uint256 callGasLimit; UOO+0x80
//    uint256 verificationGasLimit; UOO+0xa0
//    uint256 preVerificationGas; UOO+0xc0
//    uint256 maxFeePerGas; UOO+0xe0
//    uint256 maxPriorityFeePerGas; UOO+0x100
//    bytes paymasterAndData; UOO+0x120
//    bytes signature; UOO+0x140
//}

// Memory Layout
// [0x00 ~ 0x20) : scratch space
// [0x20 ~ 0x40) : scratch space
// [0x40 ~ 0x60) : memory size
// [0x60 ~ 0x80) : zero slots ( The zero slot is used as initial value for dynamic memory arrays and should never be written to (the free memory pointer points to 0x80 initially). )
// [0x80 ~ 0xa0) : bundleSize
// [0xa0 ~ 0xc0) : currentUserOp
// [0xc0 ~ 0xe0] : currentUserOpLength
// THEN: current UserOp formatted for validateUserOp function call
// [0xe0 ~ 0xe4) : validateUserOpFunctionSig (0x0825d1fc)
// [0xe4 ~ 0x104) : currentUserOpOffset (0x60)
// [0x104 ~ 0x124) : currentUserOpHash
// [0x124 ~ 0x144) : missingAccountFunds
// [0x144 ~ ...) : currentUserOp

#define macro GET_USEROP_HASH() = takes(0) returns(0) {
      // [...]
      0xa0 mload // [currentOpIndex, UserOp_Offset]
      0x20 mul                    
      0x64 add dup1 calldataload // [userOp_i_offset, currentOpIndex, UserOp_Offset]
      swap1 0x20 add calldataload sub // [userOp_i_length, UserOp_Offset]
      dup2 0x144 // [memoryOffset, calldataOffset (UserOp_Offset), userOp_i_length, UserOp_Offset]
      calldatacopy // [UserOp_Offset]

      0x184 mload 0x144 add dup1 mload // [initCodeSize, initCodeSizeSlot]
      swap1 0x20 add // [initCodeStartSlot, initCodeSize]
      sha3 // [initCodeHash]
      0x184 mstore

      0x1a4 mload 0x144 add dup1 mload // [callDataSize, callDataSizeSlot]
      swap1 0x20 add // [callDataSlot, callDataSize]
      sha3 // [callDataHash]
      0x1a4 mstore

      0x264 mload 0x144 add dup1 mload // [paymasterDataSize,paymasterDataSizeSlot]
      swap1 0x20 add // [paymasterDataSlot, paymasterDataSize]
      sha3 // [paymasterDataHash]
      0x264 mstore

      0x140 0x144 sha3
      0x00 mstore
      address 0x20 mstore
      chainid 0x40 mstore
      0x60 0x00 sha3
      0x104 mstore
}

#define macro COPY_USEROP() = takes(1) returns(2){
    // [UserOp_Offset]
    0xa0 mload // [currentOpIndex, UserOp_Offset]]
    0x20 mul                    
    0x64 add dup1 calldataload // [userOp_i_offset, currentOpIndex, UserOp_Offset]
    swap1 0x20 add calldataload sub // [userOp_i_length, UserOp_Offset]
    dup1 0xc0 mstore // [userOp_i_length, UserOp_Offset]
    __RIGHTPAD(0x3a871cdd) 0xe0 mstore // [userOp_i_length, UserOp_Offset]
    0x60 0xe4 mstore // [userOp_i_length, UserOp_Offset]
    dup2 0x144 // [memoryOffset, calldataOffset (UserOp_Offset), userOp_i_length, UserOp_Offset]
    calldatacopy // [UserOp_Offset]
    // 0xc0 mload 0x84 add 0xc0 return // example: return [0xc0 - end of UO]
}

#define macro VALIDATE_PREPAYMENT() = takes(2) returns(2) {
    // [userOp_i_offset]
    // @TODO
}

#define macro CREATE_ACCOUNT() = takes(2) returns(2) {
  // [userOp_i_offset]
  // @TODO: route account creation through senderCreator contract
  0x144 mload 0x00 dup1 // [target, 0, target, userOp_i_offset]
  extcodesize // [extcodesize, 0, target, userOp_i_offset]
  gt accountDeployed jumpi // [target, userOp_i_offset]
  0x184 mload 0x144 add dup1 mload dup1 // [initCodeLength, initCodeLengthSlot, target, userOp_i_offset]
  iszero invalidUserOp jumpi // [initCodeLength, initCodeLengthSlot, target, userOp_i_offset]
  0x14 swap1 sub // [initCodeLength, initCodeLengthSlot, target, userOp_i_offset]

  0x00 // [retOffset, initCodeLength, initCodeLengthSlot, target, userOp_i_offset]
  swap1 // [initCodeLength, retOffset, initCodeLengthSlot, target, userOp_i_offset]
  0x20 // [retSize, initCodeLength, retOffset, initCodeLengthSlot, target, userOp_i_offset]
  swap3 // [initCodeLengthSlot, initCodeLength, retOffset, retSize, target, userOp_i_offset]
  dup1 0x34 add swap1 // [initCodeLengthSlot, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  0x00 swap1 // [initCodeLengthSlot, value, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  0x20 add mload 0x60 shr // [target, value, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  gas // [gas, target, value, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  call // [success, target, userOp_i_offset]
  iszero invalidUserOp jumpi // [target, userOp_i_offset]
  0x00 mload eq iszero invalidUserOp jumpi // [userOp_i_offset]

  accountDeployed:
}

#define macro CALL_VALIDATE_ON_ACCOUNT() = takes(2) returns(2) {
  // [userOp_i_offset] 

  // @TODO: MISSING ACCOUNT FUNDS

  0x20 // [retSize, userOp_i_offset]
  0x00 // [retOffset, retSize, userOp_i_offset]
  0xc0 mload 0x64 add // [UO_length, retOffset, retSize, userOp_i_offset]
  0xe0 // [argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x00 // [value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x144 mload // [target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x1e4 mload // [gas, target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  call // [success, userOp_i_offset]
  iszero invalidUserOp jumpi // [userOp_i_offset]
  0x00 mload 0x00 eq iszero invalidUserOp jumpi // [userOp_i_offset]
  // @TODO validate the return value
}

#define macro CALL_EXECUTE_ON_ACCOUNT() = takes(2) returns(2) {
  // [userOp_i_offset] 
  0x00 // [retSize, userOp_i_offset]
  0x00 // [retOffset, retSize, userOp_i_offset]
  0x1a4 mload 0x144 add dup1 mload // [UO_length, calldataOffset, retOffset, retSize, userOp_i_offset]
  swap1 0x20 add // [argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x00 // [value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x144 mload // [target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0xc4 mload // [gas, target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  call // [success, userOp_i_offset]
  iszero invalidUserOp jumpi // [userOp_i_offset]
}

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xE0 shr
    dup1 0x1fad948c eq handle_ops jumpi  // jump to handleOps
    0xa6193531 eq getUserOpHash jumpi
    
    handle_ops:
      pop
      0x44                          // [userOps_offset]
      dup1                          // [userOps_offset, userOps_offset]
      calldataload                  // [userOps_length, userOps_offset]
      0x80 mstore                   // [userOps_offset]
      0x20 add                      // [userOps_offset]
      dup1                          // [cursor, userOps_offset]
    loop_verification_phase:
      dup1                          // [cursor, cursor, userOps_offset]
      calldataload                  // [userOp_rel_offset, cursor, userOps_offset]
      dup2 add                      // [userOp_i_offset, cursor, userOps_offset]
      0x80 mload                    // [bundleSize, userOp_i_offset, cursor, userOps_offset]
      // @TODO: keep [0xa0 mload] on stack to use below
      0xa0 mload                    // [current_i, bundleSize, userOp_i_offset, cursor, userOps_offset]
      eq execution_phase jumpi      // [userOp_i_offset, cursor, userOps_offset]
      GET_USEROP_HASH()             // [userOp_i_offset]
      COPY_USEROP()                 // [userOp_i_offset]
      CREATE_ACCOUNT()              // [userOp_i_offset]
      CALL_VALIDATE_ON_ACCOUNT()    // [userOp_i_offset]
      VALIDATE_PREPAYMENT()         // [userOp_i_offset]
      pop 0x20 add                  // [newCalldataCursor, userOp_i_offset] 
      0xa0 mload                    // [UOCursor, newCalldataCursor, userOp_i_offset] 
      0x01 add 0xa0 mstore          // [newCalldataCursor, userOps_offset]
      loop_verification_phase jump  // [newCalldataCursor, userOps_offset]
    execution_phase:
      0x00 0xa0 mstore
      pop
      0x44                          // [userOps_offset]
      dup1                          // [userOps_offset, userOps_offset]
      calldataload                  // [userOps_length, userOps_offset]
      0x80 mstore                   // [userOps_offset]
      0x20 add                      // [userOps_offset]
      dup1                          // [cursor, userOps_offset]
      execution_phase_internal:
        dup1                          // [cursor, cursor, userOps_offset]
        calldataload                  // [userOp_rel_offset, cursor, userOps_offset]
        dup2 add                      // [userOp_i_offset, cursor, userOps_offset]
        0x80 mload                    // [opSize, userOp_i_offset]
        // @TODO: keep [0xa0 mload] on stack to use below
        0xa0 mload                    // [current_i, opSize, userOp_i_offset]
        eq finish jumpi               // [userOp_i_offset]
        COPY_USEROP()                 // [userOp_i_offset]
        CALL_EXECUTE_ON_ACCOUNT()     // [userOp_i_offset]
        pop 0x20 add                  // [newCalldataCursor, userOp_i_offset] 
        0xa0 mload                    // [UOCursor, newCalldataCursor, userOp_i_offset] 
        0x01 add 0xa0 mstore          // [newCalldataCursor, userOps_offset]
        swap1 0x20 add              // [cursor, userOps_offset]    
        execution_phase_internal jump
    getUserOpHash:
      0x04 calldatasize sub // [uoSize]
      0x04 0x00 calldatacopy // []

      0x60 mload 0x20 add dup1 mload // [initCodeSize, initCodeSizeSlot]
      swap1 0x20 add // [initCodeStartSlot, initCodeSize]
      sha3 // [initCodeHash]
      0x60 mstore

      0x80 mload 0x20 add dup1 mload // [callDataSize, callDataSizeSlot]
      swap1 0x20 add // [callDataSlot, callDataSize]
      sha3 // [callDataHash]
      0x80 mstore

      0x140 mload 0x20 add dup1 mload // [paymasterDataSize,paymasterDataSizeSlot]
      swap1 0x20 add // [paymasterDataSlot, paymasterDataSize]
      sha3 // [paymasterDataHash]
      0x140 mstore

      0x140 0x20 sha3
      0x00 mstore
      address 0x20 mstore
      chainid 0x40 mstore
      0x60 0x00 sha3
      0x00 mstore
      0x20 0x00 return
    finish:
      stop
    invalidUserOp:
      0x00 0x00 revert
}
